{
  "name": "gl-shader",
  "version": "3.0.0",
  "description": "WebGL shader wrapper",
  "main": "index.js",
  "directories": {
    "example": "example"
  },
  "dependencies": {
    "uniq": "^0.0.2",
    "gl-shader-core": "^2.0.0",
    "glsl-extract": "^0.0.2",
    "through": "~2.3.4"
  },
  "devDependencies": {
    "gl-now": "~0.0.0"
  },
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "beefy --open example/example.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/mikolalysenko/gl-shader.git"
  },
  "keywords": [
    "webgl",
    "shader",
    "fragment",
    "vertex",
    "uniform",
    "attribute",
    "wrap",
    "3d",
    "gl"
  ],
  "author": {
    "name": "Mikola Lysenko"
  },
  "license": "MIT",
  "readmeFilename": "README.md",
  "gitHead": "e28ce1d36277aeb6d109d886e847c7cdc1903cd9",
  "bugs": {
    "url": "https://github.com/mikolalysenko/gl-shader/issues"
  },
  "readme": "gl-shader\n=========\nSimple wrapper for WebGL shaders\n\n# Example\n\nTry it out now in your browser:  [http://mikolalysenko.github.io/gl-shader/](http://mikolalysenko.github.io/gl-shader/)\n\n```javascript\nvar shell = require(\"gl-now\")()\nvar createShader = require(\"gl-shader\")\nvar shader, buffer\n\nshell.on(\"gl-init\", function() {\n  var gl = shell.gl\n\n  //Create shader\n  shader = createShader(gl,\n    \"attribute vec3 position;\\\n    varying vec2 uv;\\\n    void main() {\\\n      gl_Position = vec4(position, 1.0);\\\n      uv = position.xy;\\\n    }\",\n    \"precision highp float;\\\n    uniform float t;\\\n    varying vec2 uv;\\\n    void main() {\\\n      gl_FragColor = vec4(0.5*(uv+1.0), 0.5*(cos(t)+1.0), 1.0);\\\n    }\")\n\n  //Create vertex buffer\n  buffer = gl.createBuffer()\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer)\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n    -1, 0, 0,\n    0, -1, 0,\n    1, 1, 0\n  ]), gl.STATIC_DRAW)\n})\n\nshell.on(\"gl-render\", function(t) {\n  var gl = shell.gl\n\n  //Bind shader\n  shader.bind()\n  \n  //Set attributes\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer)\n  shader.attributes.position.pointer()\n\n  //Set uniforms\n  shader.uniforms.t += 0.01\n\n  //Draw\n  gl.drawArrays(gl.TRIANGLES, 0, 3)\n})\n```\n\nHere is the result:\n\n<img src=\"https://raw.github.com/mikolalysenko/gl-shader/master/screenshot.png\">\n\n# Install\n\n    npm install gl-shader\n\n# API\n\n```javascript\nvar createShader = require(\"gl-shader\")\n```\n\n### `var shader = createShader(gl, vert_src, frag_src)`\nCreates a shader in the WebGL context with the given vertex and fragment shader sources.\n\n* `gl` is the WebGL context to create the shader in\n* `vert_src` is the vertex shader source\n* `frag_src` is the fragment shader source\n\n**Returns** A `GLShader` object which wraps a WebGL program\n\n**Throws** If there are any errors when creating the shader.\n\n### `shader.gl`\nA reference to the WebGL context of the shader.\n\n### `shader.handle`\nA handle to the underlying WebGLProgram object that the shader wraps.\n\n### `shader.fragmentShader`\nA handle to the underlying fragment shader object.\n\n### `shader.vertexShader`\nA handle to the underlying vertex shader object.\n\n### `shader.bind()`\nBinds the shader to the currently used program.  Essentially a shorthand for:\n\n```javascript\ngl.useProgram(shader.program)\n```\n\n### `shader.dispose()`\nRelease all resources associated with the shader\n\n## Uniforms\nThe uniforms for the shader program are packaged up as properties in the `shader.uniforms` object.  For example, to update a scalar uniform you can just assign to it:\n\n```javascript\nshader.uniforms.scalar = 1.0\n```\n\nWhile you can update vector uniforms by writing an array to them:\n\n```javascript\nshader.uniforms.vector = [1,0,1,0]\n```\n\nMatrix uniforms must have their arrays flattened first:\n\n```javascript\nshader.uniforms.matrix = [ 1, 0, 1, 0,\n                           0, 1, 0, 0,\n                           0, 0, 1, 1,\n                           0, 0, 0, 1 ]\n```\n\nYou can also read the value of uniform too if the underlying shader is currently bound.  For example,\n\n```javascript\nconsole.log(shader.uniforms.scalar)\nconsole.log(shader.uniforms.vector)\nconsole.log(shader.uniforms.matrix)\n```\n\nStruct uniforms can also be accessed using the normal dot property syntax.  For example,\n\n```javascript\nshader.uniforms.light[0].color = [1, 0, 0, 1]\n```\n\nYou can also assign to structs or even entire collections of uniforms by writing to them with an object:\n\n```javascript\nshader.uniforms = {\n  color: [1, 0, 0, 1],\n  intensity: 100.0,\n  light: {\n    position: [0, 0, 0],\n    direction: [1, 0, 0]\n  }\n}\n```\n\n## Attributes\n\nThe basic idea behind the attribute interface is similar to that for uniforms, however because attributes can be either a constant value or get values from a vertex array the situation is slightly more complicated.  All of the attributes are stored in the `shader.attributes` property.\n\n### `attrib = value`\nFor non-array attributes you can set the constant value to be broadcast across all vertices.  For example, to set the vertex color of a shader to a constant you could do:\n\n```javascript\nshader.attributes.color = [1, 0, 0, 1]\n```\n\nThis internally uses [`gl.vertexAttribnf`](http://www.khronos.org/opengles/sdk/docs/man/xhtml/glVertexAttrib.xml).\n\n### `attrib.location`\nThis property accesses the location of the attribute.  You can assign/read from it to modify the location of the attribute.  For example, you can update the location by doing:\n\n```javascript\nattrib.location = 0\n```\n\nOr you can read the currently bound location back by just accessing it:\n\n```javascript\nconsole.log(attrib.location)\n```\n\nInternally, these methods just call [`gl.bindAttribLocation`](http://www.khronos.org/opengles/sdk/docs/man/xhtml/glBindAttribLocation.xml) and access the stored location.\n\n**WARNING** Changing the attribute location requires recompiling the program.  Do not dynamically modify this variable in your render loop.\n\n### `attrib.pointer([type, normalized, stride, offset])`\nA shortcut for `gl.vertexAttribPointer`.  See the [OpenGL man page for details on how this works](http://www.khronos.org/opengles/sdk/docs/man/xhtml/glVertexAttribPointer.xml).  The main difference here is that the WebGL context, size and index are known and so these parameters are bound.\n\n* `type` is the type of the pointer (default `gl.FLOAT`)\n* `normalized` specifies whether fixed-point data values should be normalized (`true`) or converted directly as fixed-point values (`false`) when they are accessed.  (Default `false`)\n* `stride` the byte offset between consecutive generic vertex attributes.  (Default: `0`)\n* `offset` offset of the first element of the array in bytes. (Default `0`)\n\n## Reflection\n\nFinally, the library supports some reflection capabilities.  The set of all uniforms and data types are stored in the \"type\" property of the shader object,\n\n```javascript\nconsole.log(shader.types)\n```\n\n## Credits\n(c) 2013 Mikola Lysenko. MIT License",
  "homepage": "https://github.com/mikolalysenko/gl-shader",
  "_id": "gl-shader@3.0.0",
  "dist": {
    "shasum": "7fcff02722dbf15dd35666ccf37336b19098aec3"
  },
  "_from": "gl-shader@^3.0.0",
  "_resolved": "https://registry.npmjs.org/gl-shader/-/gl-shader-3.0.0.tgz"
}
